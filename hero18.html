<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>hero 18</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #f0ece6;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
  }
  #hero {
    position: relative;
    width: 900px;
    height: 600px;
  }
  #scene {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 560px;
    height: 480px;
    display: block;
    z-index: 0;
  }
  #overlay {
    position: absolute;
    inset: 0;
    z-index: 2;
    pointer-events: none;
  }

  #slogan {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: white;
    font-family: 'Arial', sans-serif;
    z-index: 10; /* ensures it sits above canvas */
  }
  #slogan h1 {
    font-size: 3rem;
    margin: 0;
  }
  #slogan p {
    font-size: 1.5rem;
    margin-top: 0.5rem;
  }



</style>
</head>
<body>
<div id="hero">
  <canvas id="scene"></canvas>
  <svg id="overlay" viewBox="0 0 900 600">
    <defs>
      <radialGradient id="gloss" cx="36%" cy="28%" r="48%">
        <stop offset="0%"   stop-color="white" stop-opacity="0.18"/>
        <stop offset="60%"  stop-color="white" stop-opacity="0.02"/>
        <stop offset="100%" stop-color="white" stop-opacity="0"/>
      </radialGradient>
      <radialGradient id="vign" cx="50%" cy="50%" r="50%">
        <stop offset="58%" stop-color="black" stop-opacity="0"/>
        <stop offset="100%" stop-color="black" stop-opacity="0.7"/>
      </radialGradient>
    </defs>
    <!-- Cream bg with hole punched through — even-odd fill rule -->
    <path id="mask"   fill="#f0ece6" fill-rule="evenodd"/>
    <path id="rim"    fill="none" stroke="#c8c2ba" stroke-width="2"/>
    <path id="gloss"  fill="url(#gloss)"/>
    <path id="vign"   fill="url(#vign)"/>
  </svg>
</div>


<div id="slogan">
  <h1>Worlds<br>apart!</h1>
  <p>unconventional thinking to the maximum</p>
</div>


<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
'use strict';

// ════════════════════════════════════════════════════════════════
//  PORTHOLE — standing wave morphing edge
//  sin(n*angle) * sin(speed*t) — spatial pattern locked, amplitude breathes
// ════════════════════════════════════════════════════════════════
const PCX = 450, PCY = 308;
const PRX = 228, PRY = 192;

const MODES = [
  { n:3,  amp:10, spd:0.00088, ph:0.00 },
  { n:4,  amp: 9, spd:0.00112, ph:1.30 },
  { n:5,  amp: 8, spd:0.00074, ph:2.60 },
  { n:6,  amp: 7, spd:0.00133, ph:0.80 },
  { n:3,  amp: 7, spd:0.00061, ph:4.20 },
  { n:4,  amp: 6, spd:0.00097, ph:3.10 },
  { n:7,  amp: 5, spd:0.00152, ph:1.70 },
  { n:8,  amp: 4, spd:0.00171, ph:2.90 },
  { n:5,  amp: 5, spd:0.00086, ph:5.10 },
  { n:9,  amp: 3, spd:0.00203, ph:0.50 },
  { n:6,  amp: 4, spd:0.00117, ph:3.80 },
  { n:10, amp: 2, spd:0.00224, ph:1.10 },
  { n:11, amp: 2, spd:0.00252, ph:4.50 },
];
const NPTS = 200;

function holePath(t) {
  const pts = [];
  for (let i = 0; i < NPTS; i++) {
    const a = (i / NPTS) * Math.PI * 2;
    const cosA = Math.cos(a), sinA = Math.sin(a);
    const baseR = (PRX * PRY) / Math.sqrt((PRY*cosA)**2 + (PRX*sinA)**2);
    let off = 0;
    MODES.forEach(m => { off += Math.sin(m.n*a) * Math.sin(m.spd*t + m.ph) * m.amp; });
    pts.push({ x: PCX + cosA*(baseR+off), y: PCY + sinA*(baseR+off) });
  }
  const ten = 0.38, n = pts.length;
  let d = `M${pts[0].x.toFixed(1)} ${pts[0].y.toFixed(1)}`;
  for (let i = 0; i < n; i++) {
    const p0=pts[(i-1+n)%n], p1=pts[i], p2=pts[(i+1)%n], p3=pts[(i+2)%n];
    const c1x=p1.x+(p2.x-p0.x)*ten/3, c1y=p1.y+(p2.y-p0.y)*ten/3;
    const c2x=p2.x-(p3.x-p1.x)*ten/3, c2y=p2.y-(p3.y-p1.y)*ten/3;
    d+=` C${c1x.toFixed(1)} ${c1y.toFixed(1)},${c2x.toFixed(1)} ${c2y.toFixed(1)},${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
  }
  return d + 'Z';
}

const maskEl  = document.getElementById('mask');
const rimEl   = document.getElementById('rim');
const glossEl = document.getElementById('gloss');
const vignEl  = document.getElementById('vign');

function updateHole(t) {
  const h = holePath(t);
  maskEl.setAttribute('d',  `M0 0L900 0L900 600L0 600Z ${h}`);
  rimEl.setAttribute('d',   h);
  glossEl.setAttribute('d', h);
  vignEl.setAttribute('d',  h);
}

// ════════════════════════════════════════════════════════════════
//  THREE.JS SCENE
// ════════════════════════════════════════════════════════════════
const canvas = document.getElementById('scene');
const W = 560, H = 480;
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(W, H, false);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;

const scene = new THREE.Scene();

// ── CAMERA ──
// High up, looking down at a shallow angle so:
//   - horizon is in the bottom ~25% of frame
//   - ~75% of view is sky
const camera = new THREE.PerspectiveCamera(60, W/H, 0.1, 2000);
camera.position.set(0, 2, 18);
camera.lookAt(0, 5, -30); // low camera, aimed at distant horizon slightly above

// ── SKY DOME ──
const skyUniforms = {
  uDay:    { value: 0 },
  uSunY:   { value: -1 },
};
const skyMat = new THREE.ShaderMaterial({
  uniforms: skyUniforms,
  side: THREE.BackSide,
  depthWrite: false,
  vertexShader: `
    varying vec3 vDir;
    void main() {
      vDir = normalize((modelMatrix * vec4(position,1.0)).xyz);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform float uDay;
    uniform float uSunY;
    varying vec3 vDir;
    void main() {
      // h: 0 at horizon, 1 at zenith
      float h = clamp(vDir.y * 2.0, 0.0, 1.0);
      float sunUp = clamp(uSunY, 0.0, 1.0);

      // Night colours
      vec3 nightZen = vec3(0.005, 0.002, 0.04);
      vec3 nightHor = vec3(0.01,  0.005, 0.06);
      // Day colours
      vec3 dayZen   = vec3(0.03, 0.05, 0.28);
      vec3 dayHor   = vec3(0.55, 0.18, 0.03);
      // Sunrise/set orange band near horizon
      vec3 sunsetHor= vec3(1.0, 0.45, 0.05);

      vec3 zen = mix(nightZen, dayZen, uDay);
      vec3 hor = mix(nightHor, mix(dayHor, sunsetHor, sunUp), uDay);

      vec3 col = mix(hor, zen, pow(h, 0.38));
      gl_FragColor = vec4(col, 1.0);
    }
  `,
});
scene.add(new THREE.Mesh(new THREE.SphereGeometry(600, 32, 16), skyMat));

// ── STARS ──
// Key insight: place stars in WORLD SPACE at fixed high Y positions.
// They will always be above the terrain/horizon regardless of camera.
// Three layers: large+bright, medium, small+dim. Each twinkles individually.

const starData = []; // { mesh, phases, speeds }

function makeStars(count, size, col, yMin, yMax, spread) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const phases = new Float32Array(count);
  const speeds  = new Float32Array(count);

  for (let i = 0; i < count; i++) {
    // Random position in a high disc above scene
    const angle = Math.random() * Math.PI * 2;
    const dist  = 150 + Math.random() * spread;
    pos[i*3]   = Math.cos(angle) * dist;
    pos[i*3+1] = yMin + Math.random() * (yMax - yMin); // always high Y
    pos[i*3+2] = -20 - Math.random() * 180; // distributed in sky depth
    phases[i]  = Math.random() * Math.PI * 2;
    speeds[i]  = 0.4 + Math.random() * 2.0;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  const mat = new THREE.PointsMaterial({
    color: col, size, transparent: true, opacity: 0,
    blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: false,
  });
  const pts = new THREE.Points(geo, mat);
  scene.add(pts);
  starData.push({ pts, mat, phases, speeds, count, baseOp: mat.opacity });
  return pts;
}

// sizeAttenuation: false so sizes are in screen pixels, not world units
// Stars placed in sky — Y must be ABOVE camera (y>2) and in front (z negative)
// Spread around in a band at sky height, not too far in Z
const starsBig   = makeStars(80,   3.5, 0xfff5e0, 8,  60, 200);  // large bright
const starsMed   = makeStars(600,  2.0, 0xffeedd, 6,  60, 250);  // medium  
const starsSmall = makeStars(1400, 1.2, 0xccccff, 4,  60, 300);  // tiny

// ── SUN ──
const sunMesh = new THREE.Mesh(
  new THREE.SphereGeometry(7, 24, 24),
  new THREE.MeshBasicMaterial({ color: 0xffee55 })
);
const sunGlow = new THREE.Mesh(
  new THREE.SphereGeometry(12, 24, 24),
  new THREE.MeshBasicMaterial({
    color: 0xff9900, transparent: true, opacity: 0.22,
    blending: THREE.AdditiveBlending, depthWrite: false,
  })
);
scene.add(sunMesh);
scene.add(sunGlow);

const sunLight = new THREE.DirectionalLight(0xffd580, 5.0);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(2048, 2048);
['left','right','top','bottom'].forEach((k,i) =>
  sunLight.shadow.camera[k] = [-60,60,60,-60][i]
);
scene.add(sunLight);

// ── MOON (big, left side, descends through sky) ──
// Radius 10 — present but not absurd
const MOON_R = 10;
const moonMesh = new THREE.Mesh(
  new THREE.SphereGeometry(MOON_R, 40, 40),
  new THREE.MeshStandardMaterial({ color: 0xc8b8e0, roughness: 0.88, metalness: 0 })
);
const moonGlow = new THREE.Mesh(
  new THREE.SphereGeometry(MOON_R + 3.5, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0x7755bb, transparent: true, opacity: 0.18,
    blending: THREE.AdditiveBlending, depthWrite: false,
  })
);
const moonRim = new THREE.Mesh(
  new THREE.SphereGeometry(MOON_R + 1.5, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0xccaaff, transparent: true, opacity: 0.09,
    blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.BackSide,
  })
);
scene.add(moonMesh);
scene.add(moonGlow);
scene.add(moonRim);

const moonLight = new THREE.PointLight(0x9977cc, 3.0, 200);
scene.add(moonLight);

// Moon arc: LEFT side of sky, comes from top-left, descends, sets behind left mountains
// X stays negative (left), Y goes from high to below horizon over ~50s cycle
const MOON_CYCLE = 50;
// X: -28 to -42 (drifts slightly further left as it descends — parallax feel)
// Y: 80 (top of sky) → -18 (behind mountains)
// Z: -30 (distant) — stays far back so it doesn't intersect terrain

function moonPos(sec) {
  const t = (sec % MOON_CYCLE) / MOON_CYCLE; // 0..1
  const ease = t; // linear descent
  return {
    x: -28 - ease * 14,   // left, drifts further left
    y:  80 - ease * 98,   // top to below horizon
    z: -30,
  };
}

// ── AMBIENT ──
const ambLight  = new THREE.AmbientLight(0x221133, 2.8);
const hemiLight = new THREE.HemisphereLight(0x442266, 0x110022, 1.4);
scene.add(ambLight);
scene.add(hemiLight);

// ── TERRAIN ──
const TERRAIN_Y = -4; // terrain just below camera eye level
const terrGeo = new THREE.PlaneGeometry(350, 350, 130, 130);
(function() {
  const p = terrGeo.attributes.position.array;
  for (let i = 0; i < p.length; i += 3) {
    const x = p[i], z = p[i+1];
    p[i+2] =
      Math.sin(x*0.055)*4.5 + Math.cos(z*0.07)*3.5 +
      Math.sin((x+z)*0.04)*2.5 + Math.sin(x*0.14+1.1)*1.5 +
      Math.cos(z*0.12-0.8)*1.2 + (Math.random()-0.5)*0.3;
  }
  terrGeo.computeVertexNormals();
})();
const terrMat = new THREE.MeshStandardMaterial({ color: 0x150228, roughness: 0.95, metalness: 0.05 });
const terrain = new THREE.Mesh(terrGeo, terrMat);
terrain.rotation.x = -Math.PI/2;
terrain.position.y = TERRAIN_Y;
terrain.receiveShadow = true;
scene.add(terrain);

// ── MOUNTAIN SILHOUETTES ──
// These form the horizon. Moon will descend behind the left side.
function addMtns(zOff, col, peaks, maxH, yBase) {
  const s = new THREE.Shape();
  s.moveTo(-160, -20);
  for (let i = 0; i <= peaks; i++) {
    const x = -160 + (i/peaks)*320;
    const h = 4 + Math.sin(i*2.1 + zOff)*6 + Math.random()*maxH;
    s.lineTo(x, h);
  }
  s.lineTo(160, -20);
  s.closePath();
  const m = new THREE.Mesh(
    new THREE.ShapeGeometry(s),
    new THREE.MeshBasicMaterial({ color: col, side: THREE.DoubleSide, depthWrite: false })
  );
  m.rotation.x = -Math.PI/2;
  m.position.set(0, yBase, zOff);
  scene.add(m);
}
addMtns(-50, 0x080115, 24, 22, TERRAIN_Y + 0.3);
addMtns(-38, 0x0c0220, 20, 17, TERRAIN_Y + 0.4);
addMtns(-26, 0x100330, 16, 12, TERRAIN_Y + 0.5);
addMtns(-16, 0x14043a, 12,  8, TERRAIN_Y + 0.6);

// ── CRYSTAL SPIRES ──
const SPIRE_COLS = [0x6600cc,0x4400aa,0x220066,0x9900ff,0x3300bb,0xaa22ff,0x7711dd];
const spires = [];
[
  [-8,-6,5.5],[5,-7,7],[-13,-3,4.5],[10,-4,8.5],[-6,-13,6.5],[14,-9,3.5],
  [-18,-11,5],[2,-16,9.5],[8,-14,4.5],[-10,1,7.5],[16,0,3.5],[-3,3,6],
  [12,4,4.5],[-15,3,5.5],[6,1,8],[-4,-8,7],[9,-9,5],[-12,-7,8],
].forEach(([x,z,h]) => {
  const r = 0.2 + Math.random()*0.55;
  const col = SPIRE_COLS[Math.floor(Math.random()*SPIRE_COLS.length)];
  const geo = new THREE.ConeGeometry(r, h, 5+Math.floor(Math.random()*3));
  // Twist vertices
  const sp = geo.attributes.position.array;
  for (let i = 0; i < sp.length; i += 3) {
    const yf = (sp[i+1]+h/2)/h, tw = yf*0.5;
    const ox = sp[i], oz = sp[i+2];
    sp[i]   = ox*Math.cos(tw)-oz*Math.sin(tw);
    sp[i+2] = ox*Math.sin(tw)+oz*Math.cos(tw);
  }
  geo.computeVertexNormals();
  const c = new THREE.Color(col);
  const mat = new THREE.MeshStandardMaterial({
    color:c, emissive:c, emissiveIntensity:0.5,
    roughness:0.2, metalness:0.8, transparent:true, opacity:0.88,
  });
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x, TERRAIN_Y+h/2, z);
  m.castShadow = true;
  scene.add(m);
  spires.push(m);
});

// ── BIOLUMINESCENT FLORA ──
const floraOrbs = [];
for (let i = 0; i < 28; i++) {
  const x = (Math.random()-0.5)*55, z = -Math.random()*20-2;
  const h = 0.5 + Math.random()*2.5;
  const stalk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.04, 0.08, h, 5),
    new THREE.MeshStandardMaterial({ color:0x1a0030, roughness:0.9 })
  );
  stalk.position.set(x, TERRAIN_Y+h/2, z);
  scene.add(stalk);
  const orbR = 0.12 + Math.random()*0.25;
  const hue  = 0.65 + Math.random()*0.38;
  const col  = new THREE.Color().setHSL(hue, 1, 0.62);
  const orb  = new THREE.Mesh(
    new THREE.SphereGeometry(orbR, 10, 10),
    new THREE.MeshStandardMaterial({ color:col, emissive:col, emissiveIntensity:2.0 })
  );
  orb.position.set(x, TERRAIN_Y+h+orbR, z);
  orb.userData.ph = Math.random()*Math.PI*2;
  scene.add(orb);
  floraOrbs.push(orb);
}

// ── FLOATING PARTICLES ──
const PCNT = 350;
const pGeo = new THREE.BufferGeometry();
const pBuf = new Float32Array(PCNT*3);
const pPh  = new Float32Array(PCNT);
for (let i = 0; i < PCNT; i++) {
  pBuf[i*3]   = (Math.random()-0.5)*50;
  pBuf[i*3+1] = TERRAIN_Y + 1 + Math.random()*12;
  pBuf[i*3+2] = -Math.random()*25;
  pPh[i] = Math.random()*Math.PI*2;
}
pGeo.setAttribute('position', new THREE.BufferAttribute(pBuf, 3));
const pMat = new THREE.PointsMaterial({
  color:0xaa66ff, size:0.055, transparent:true, opacity:0.5,
  blending:THREE.AdditiveBlending, depthWrite:false,
});
scene.add(new THREE.Points(pGeo, pMat));

// ════════════════════════════════════════════════════════════════
//  RENDER LOOP
// ════════════════════════════════════════════════════════════════
const DAY_CYCLE = 24; // seconds per full day
let t0 = null;

function tick(ts) {
  if (!t0) t0 = ts;
  const ms  = ts - t0;
  const sec = ms / 1000;

  // Day/night phase [0=night .. 1=day]
  const dayPhase = (Math.sin(sec*Math.PI*2/DAY_CYCLE - Math.PI/2) + 1) / 2;

  // ── Sun arc ──
  const sunA = sec*Math.PI*2/DAY_CYCLE - Math.PI/2;
  const SX = Math.cos(sunA)*170, SY = Math.sin(sunA)*110, SZ = -100;
  sunMesh.position.set(SX, SY, SZ);
  sunGlow.position.set(SX, SY, SZ);
  sunLight.position.set(SX, SY, SZ);
  const sunUp = Math.max(0, SY/110);
  sunLight.intensity = sunUp * 6;
  sunMesh.visible = SY > -20; sunGlow.visible = SY > -24;
  sunMesh.material.color.setHSL(0.12-sunUp*0.04, 1, 0.5+sunUp*0.14);
  sunLight.color.setHSL(0.10-sunUp*0.03, 0.9, 0.7+sunUp*0.1);
  skyUniforms.uDay.value  = dayPhase;
  skyUniforms.uSunY.value = SY/110;

  // ── Moon descends left side ──
  const mp = moonPos(sec);
  moonMesh.position.set(mp.x, mp.y, mp.z);
  moonGlow.position.set(mp.x, mp.y, mp.z);
  moonRim.position.set(mp.x, mp.y, mp.z);
  moonLight.position.set(mp.x, mp.y, mp.z);
  // Visible above horizon (y > TERRAIN_Y + 2)
  const moonAbove = mp.y > TERRAIN_Y + 2;
  moonMesh.visible = moonAbove;
  moonGlow.visible = moonAbove;
  moonRim.visible  = moonAbove;
  // Moon glow brighter at night
  moonGlow.material.opacity = (0.15 + (1-dayPhase)*0.25) * (moonAbove ? 1 : 0);
  moonLight.intensity = moonAbove ? (2.5 + (1-dayPhase)*3.0) : 0;

  // ── Stars — twinkle per star, fade with daylight ──
  const nightF = Math.max(0, 1 - dayPhase*3.0);
  const baseOps = [0.90, 0.68, 0.38];
  starData.forEach((layer, li) => {
    if (nightF <= 0) { layer.mat.opacity = 0; return; }
    // Slowly drift the whole layer (barely perceptible rotation)
    layer.pts.rotation.y += 0.000008;
    // Average twinkle — per-star would require vertex colors; approximate per-layer
    const twinkle = 0.80 + 0.20 * Math.sin(sec * 0.7 + li * 2.1);
    layer.mat.opacity = nightF * baseOps[li] * twinkle;
  });

  // ── Ambient lights shift day/night ──
  ambLight.color.setHSL(0.76, 0.55, 0.04 + dayPhase*0.08);
  ambLight.intensity = 2.2 + dayPhase*2.0;
  hemiLight.intensity = 1.0 + dayPhase*1.2;
  terrMat.color.setHSL(0.78, 0.82, 0.025 + dayPhase*0.06);

  // ── Spires pulse brighter at night ──
  spires.forEach((s,i) => {
    s.material.emissiveIntensity = 0.4 + Math.sin(sec*1.2+i*0.65)*0.2 + (1-dayPhase)*0.9;
  });

  // ── Flora pulse ──
  floraOrbs.forEach(o => {
    o.material.emissiveIntensity = 1.8 + Math.sin(sec*1.9+o.userData.ph)*0.6 + (1-dayPhase)*1.2;
  });

  // ── Particles drift upward ──
  const pp = pGeo.attributes.position.array;
  for (let i = 0; i < PCNT; i++) {
    pp[i*3+1] += 0.004 + Math.sin(pPh[i]+sec)*0.001;
    pp[i*3]   += Math.sin(pPh[i]*1.3+sec*0.35)*0.002;
    if (pp[i*3+1] > TERRAIN_Y+14) pp[i*3+1] = TERRAIN_Y+1;
  }
  pGeo.attributes.position.needsUpdate = true;

  // ── Camera FIXED ──
  camera.position.set(0, 2, 18);
  camera.lookAt(0, 5, -30);

  // ── Porthole ──
  updateHole(ms);

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}

requestAnimationFrame(tick);
</script>
</body>
</html>
