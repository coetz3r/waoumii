<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>hero 18 â€“ landscape porthole + white text</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    padding: 0;
    background: var(--bg-color);
    transition: background 0.3s;
  }
  /* Light mode (default) */
  body.light-mode {
    --bg-color: #ffffff;
    --mask-fill: #ffffff;
    --rim-color: #c0b8b0;
    --text-color: #ffffff;      /* white in light mode */
  }
  /* Dark mode */
  body.dark-mode {
    --bg-color: #111111;
    --mask-fill: #111111;
    --rim-color: #555555;
    --text-color: #eeeeee;
  }

  #theme-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 100;
    background: rgba(128,128,128,0.3);
    border: none;
    border-radius: 30px;
    width: 50px;
    height: 50px;
    font-size: 24px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    color: var(--text-color);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: 0.2s;
  }
  #theme-toggle:hover {
    background: rgba(128,128,128,0.5);
  }

  #hero {
    position: relative;
    width: auto;
    height: 90vh;
    max-width: 100%;
    aspect-ratio: 900 / 600;
    overflow: hidden;
    border-radius: 0;
    box-shadow: none;
  }
  #scene {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    display: block;
    z-index: 0;
  }
  #overlay {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
    pointer-events: none;
    /* Maintain aspect ratio of the viewBox */
    preserveAspectRatio: xMidYMid meet;
  }
  #slogan {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: var(--text-color);
    font-family: 'Arial', sans-serif;
    z-index: 10;
    width: 80%;
    text-shadow: 0 2px 8px rgba(0,0,0,0.5);
    transition: color 0.3s;
  }
  #slogan h1 {
    font-size: clamp(2rem, 8vw, 3rem);
    margin: 0;
    line-height: 1.2;
  }
  #slogan p {
    font-size: clamp(1rem, 4vw, 1.5rem);
    margin-top: 0.5rem;
  }

  /* SVG elements */
  #mask {
    fill: var(--mask-fill);
  }
  #rim {
    /* stroke: var(--rim-color); */
    stroke-width: 2;
    fill: none;
  }
</style>
</head>
<body class="light-mode">
  <button id="theme-toggle" aria-label="Toggle light/dark mode">ğŸŒ™</button>

<div id="hero">
  <canvas id="scene"></canvas>
  <svg id="overlay" viewBox="0 0 900 600" preserveAspectRatio="xMidYMid meet">
    <defs>
      <radialGradient id="gloss" cx="36%" cy="28%" r="48%">
        <stop offset="0%"   stop-color="white" stop-opacity="0.18"/>
        <stop offset="60%"  stop-color="white" stop-opacity="0.02"/>
        <stop offset="100%" stop-color="white" stop-opacity="0"/>
      </radialGradient>
      <radialGradient id="vign" cx="50%" cy="50%" r="50%">
        <stop offset="58%" stop-color="black" stop-opacity="0"/>
        <stop offset="100%" stop-color="black" stop-opacity="0.7"/>
      </radialGradient>
    </defs>
    <path id="mask"   fill-rule="evenodd"/>
    <path id="rim"    fill="none" />
    <path id="gloss"  fill="url(#gloss)"/>
    <path id="vign"   fill="url(#vign)"/>
    <!-- Optional SVG text (uncomment to use instead of HTML slogan) -->
    <!--
    <text x="450" y="280" text-anchor="middle" fill="white" font-family="Arial" font-size="48" font-weight="bold" filter="url(#shadow)">Worlds apart!</text>
    <text x="450" y="340" text-anchor="middle" fill="white" font-family="Arial" font-size="24">unconventional thinking to the maximum</text>
    -->
  </svg>
  <div id="slogan">
    <h1>Worlds<br>apart!</h1>
    <p>unconventional thinking to the maximum</p>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
'use strict';

// ========== LIGHT/DARK TOGGLE ==========
const toggleBtn = document.getElementById('theme-toggle');
toggleBtn.addEventListener('click', () => {
  if (document.body.classList.contains('light-mode')) {
    document.body.classList.remove('light-mode');
    document.body.classList.add('dark-mode');
    toggleBtn.textContent = 'â˜€ï¸';
  } else {
    document.body.classList.remove('dark-mode');
    document.body.classList.add('light-mode');
    toggleBtn.textContent = 'ğŸŒ™';
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PORTHOLE â€” standing wave morphing edge (landscape ellipse)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PCX = 450, PCY = 308;
const PRX = 228, PRY = 192;   // landscape: wider (456) than tall (384)

const MODES = [
  { n:3,  amp:10, spd:0.00088, ph:0.00 },
  { n:4,  amp: 9, spd:0.00112, ph:1.30 },
  { n:5,  amp: 8, spd:0.00074, ph:2.60 },
  { n:6,  amp: 7, spd:0.00133, ph:0.80 },
  { n:3,  amp: 7, spd:0.00061, ph:4.20 },
  { n:4,  amp: 6, spd:0.00097, ph:3.10 },
  { n:7,  amp: 5, spd:0.00152, ph:1.70 },
  { n:8,  amp: 4, spd:0.00171, ph:2.90 },
  { n:5,  amp: 5, spd:0.00086, ph:5.10 },
  { n:9,  amp: 3, spd:0.00203, ph:0.50 },
  { n:6,  amp: 4, spd:0.00117, ph:3.80 },
  { n:10, amp: 2, spd:0.00224, ph:1.10 },
  { n:11, amp: 2, spd:0.00252, ph:4.50 },
];
const NPTS = 200;

function holePath(t) {
  const pts = [];
  for (let i = 0; i < NPTS; i++) {
    const a = (i / NPTS) * Math.PI * 2;
    const cosA = Math.cos(a), sinA = Math.sin(a);
    const baseR = (PRX * PRY) / Math.sqrt((PRY*cosA)**2 + (PRX*sinA)**2);
    let off = 0;
    MODES.forEach(m => { off += Math.sin(m.n*a) * Math.sin(m.spd*t + m.ph) * m.amp; });
    pts.push({ x: PCX + cosA*(baseR+off), y: PCY + sinA*(baseR+off) });
  }
  const ten = 0.38, n = pts.length;
  let d = `M${pts[0].x.toFixed(1)} ${pts[0].y.toFixed(1)}`;
  for (let i = 0; i < n; i++) {
    const p0=pts[(i-1+n)%n], p1=pts[i], p2=pts[(i+1)%n], p3=pts[(i+2)%n];
    const c1x=p1.x+(p2.x-p0.x)*ten/3, c1y=p1.y+(p2.y-p0.y)*ten/3;
    const c2x=p2.x-(p3.x-p1.x)*ten/3, c2y=p2.y-(p3.y-p1.y)*ten/3;
    d+=` C${c1x.toFixed(1)} ${c1y.toFixed(1)},${c2x.toFixed(1)} ${c2y.toFixed(1)},${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
  }
  return d + 'Z';
}

const maskEl  = document.getElementById('mask');
const rimEl   = document.getElementById('rim');
const glossEl = document.getElementById('gloss');
const vignEl  = document.getElementById('vign');

function updateHole(t) {
  const h = holePath(t);
  maskEl.setAttribute('d',  `M0 0L900 0L900 600L0 600Z ${h}`);
  rimEl.setAttribute('d',   h);
  glossEl.setAttribute('d', h);
  vignEl.setAttribute('d',  h);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS SCENE â€” flatter terrain, distant mountains
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('scene');
const W = 560, H = 480;
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(W, H, false);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;

const scene = new THREE.Scene();

// â”€â”€ CAMERA (looks higher for more sky) â”€â”€
const camera = new THREE.PerspectiveCamera(60, W/H, 0.1, 2000);
camera.position.set(0, 2, 18);
camera.lookAt(0, 15, -30);

// â”€â”€ SKY DOME â”€â”€
const skyUniforms = {
  uDay:    { value: 0 },
  uSunY:   { value: -1 },
};
const skyMat = new THREE.ShaderMaterial({
  uniforms: skyUniforms,
  side: THREE.BackSide,
  depthWrite: false,
  vertexShader: `
    varying vec3 vDir;
    void main() {
      vDir = normalize((modelMatrix * vec4(position,1.0)).xyz);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform float uDay;
    uniform float uSunY;
    varying vec3 vDir;
    void main() {
      float h = clamp(vDir.y * 2.0, 0.0, 1.0);
      float sunUp = clamp(uSunY, 0.0, 1.0);

      vec3 nightZen = vec3(0.02, 0.01, 0.10);
      vec3 nightHor = vec3(0.03, 0.02, 0.12);
      vec3 dayZen   = vec3(0.03, 0.05, 0.28);
      vec3 dayHor   = vec3(0.55, 0.18, 0.03);
      vec3 sunsetHor= vec3(1.0, 0.45, 0.05);

      vec3 zen = mix(nightZen, dayZen, uDay);
      vec3 hor = mix(nightHor, mix(dayHor, sunsetHor, sunUp), uDay);

      vec3 col = mix(hor, zen, pow(h, 0.38));
      gl_FragColor = vec4(col, 1.0);
    }
  `,
});
scene.add(new THREE.Mesh(new THREE.SphereGeometry(600, 32, 16), skyMat));

// â”€â”€ STARS (mobile optimized) â”€â”€
const starData = [];
function makeStars(count, size, col, yMin, yMax, spread) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const phases = new Float32Array(count);
  const speeds  = new Float32Array(count);

  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist  = 150 + Math.random() * spread;
    pos[i*3]   = Math.cos(angle) * dist;
    pos[i*3+1] = yMin + Math.random() * (yMax - yMin);
    pos[i*3+2] = -20 - Math.random() * 180;
    phases[i]  = Math.random() * Math.PI * 2;
    speeds[i]  = 0.4 + Math.random() * 2.0;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  const mat = new THREE.PointsMaterial({
    color: col, size, transparent: true, opacity: 0,
    blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: false,
  });
  const pts = new THREE.Points(geo, mat);
  scene.add(pts);
  starData.push({ pts, mat, phases, speeds, count, baseOp: mat.opacity });
  return pts;
}
makeStars(60,   3.5, 0xfff5e0, 8,  60, 200);
makeStars(400,  2.0, 0xffeedd, 6,  60, 250);
makeStars(800,  1.2, 0xccccff, 4,  60, 300);

// â”€â”€ SUN â”€â”€
const sunMesh = new THREE.Mesh(
  new THREE.SphereGeometry(7, 24, 24),
  new THREE.MeshBasicMaterial({ color: 0xffee55 })
);
const sunGlow = new THREE.Mesh(
  new THREE.SphereGeometry(12, 24, 24),
  new THREE.MeshBasicMaterial({
    color: 0xff9900, transparent: true, opacity: 0.22,
    blending: THREE.AdditiveBlending, depthWrite: false,
  })
);
scene.add(sunMesh);
scene.add(sunGlow);

const sunLight = new THREE.DirectionalLight(0xffd580, 5.0);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(1024, 1024);
['left','right','top','bottom'].forEach((k,i) =>
  sunLight.shadow.camera[k] = [-60,60,60,-60][i]
);
scene.add(sunLight);

// â”€â”€ MOON â”€â”€
const MOON_R = 5;
const moonMesh = new THREE.Mesh(
  new THREE.SphereGeometry(MOON_R, 32, 32),
  new THREE.MeshStandardMaterial({ color: 0xc8b8e0, roughness: 0.88, metalness: 0 })
);
const moonGlow = new THREE.Mesh(
  new THREE.SphereGeometry(MOON_R + 2.0, 24, 24),
  new THREE.MeshBasicMaterial({
    color: 0x7755bb, transparent: true, opacity: 0.18,
    blending: THREE.AdditiveBlending, depthWrite: false,
  })
);
const moonRim = new THREE.Mesh(
  new THREE.SphereGeometry(MOON_R + 1.0, 24, 24),
  new THREE.MeshBasicMaterial({
    color: 0xccaaff, transparent: true, opacity: 0.09,
    blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.BackSide,
  })
);
scene.add(moonMesh);
scene.add(moonGlow);
scene.add(moonRim);

const moonLight = new THREE.PointLight(0x9977cc, 3.0, 200);
scene.add(moonLight);

function moonPos(sec, cycle = 120) {
  const t = (sec % cycle) / cycle;
  const theta = t * Math.PI;
  const x = -30 * Math.cos(theta);
  const y = 60 * Math.sin(theta);
  const z = 100 * Math.cos(theta);
  return { x, y, z };
}

// â”€â”€ AMBIENT â”€â”€
const ambLight  = new THREE.AmbientLight(0x332244, 3.5);
const hemiLight = new THREE.HemisphereLight(0x553377, 0x220033, 1.8);
scene.add(ambLight);
scene.add(hemiLight);

// â”€â”€ FLATTER TERRAIN â”€â”€
const TERRAIN_Y = -4;
const terrGeo = new THREE.PlaneGeometry(350, 350, 100, 100);
(function() {
  const p = terrGeo.attributes.position.array;
  for (let i = 0; i < p.length; i += 3) {
    const x = p[i], z = p[i+1];
    p[i+2] =
      Math.sin(x*0.055)*2.0 + Math.cos(z*0.07)*1.5 +
      Math.sin((x+z)*0.04)*1.2 + Math.sin(x*0.14+1.1)*0.8 +
      Math.cos(z*0.12-0.8)*0.6 + (Math.random()-0.5)*0.2;
  }
  terrGeo.computeVertexNormals();
})();
const terrMat = new THREE.MeshStandardMaterial({ 
  color: 0x2a1040,
  roughness: 0.9, 
  metalness: 0.02,
  emissive: 0x110022,
  emissiveIntensity: 0.1
});
const terrain = new THREE.Mesh(terrGeo, terrMat);
terrain.rotation.x = -Math.PI/2;
terrain.position.y = TERRAIN_Y;
terrain.receiveShadow = true;
scene.add(terrain);

// â”€â”€ DISTANT MOUNTAINS â”€â”€
function addMtns(zOff, col, peaks, maxH, yBase) {
  const s = new THREE.Shape();
  s.moveTo(-160, -20);
  for (let i = 0; i <= peaks; i++) {
    const x = -160 + (i/peaks)*320;
    const h = 2 + Math.sin(i*2.1 + zOff)*3 + Math.random()*maxH;
    s.lineTo(x, h);
  }
  s.lineTo(160, -20);
  s.closePath();
  const m = new THREE.Mesh(
    new THREE.ShapeGeometry(s),
    new THREE.MeshBasicMaterial({ color: col, side: THREE.DoubleSide, depthWrite: false })
  );
  m.rotation.x = -Math.PI/2;
  m.position.set(0, yBase, zOff);
  scene.add(m);
}
addMtns(-120, 0x1a1030, 24, 10, TERRAIN_Y + 0.2);
addMtns(-90,  0x221842, 20, 8,  TERRAIN_Y + 0.3);
addMtns(-60,  0x2a2055, 16, 6,  TERRAIN_Y + 0.4);
addMtns(-30,  0x332868, 12, 4,  TERRAIN_Y + 0.5);

// â”€â”€ CRYSTAL SPIRES â”€â”€
const SPIRE_COLS = [0x9933ff, 0x7733dd, 0x5533aa, 0xaa55ff, 0x8844ee];
const spires = [];
[
  [-8,-6,5.5],[5,-7,7],[-13,-3,4.5],[10,-4,8.5],[-6,-13,6.5],[14,-9,3.5],
  [-18,-11,5],[2,-16,9.5],[8,-14,4.5],[-10,1,7.5],[16,0,3.5],[-3,3,6],
  [12,4,4.5],[-15,3,5.5],[6,1,8],[-4,-8,7],[9,-9,5],[-12,-7,8],
].forEach(([x,z,h]) => {
  const r = 0.2 + Math.random()*0.55;
  const col = SPIRE_COLS[Math.floor(Math.random()*SPIRE_COLS.length)];
  const geo = new THREE.ConeGeometry(r, h, 5);
  const sp = geo.attributes.position.array;
  for (let i = 0; i < sp.length; i += 3) {
    const yf = (sp[i+1]+h/2)/h, tw = yf*0.5;
    const ox = sp[i], oz = sp[i+2];
    sp[i]   = ox*Math.cos(tw)-oz*Math.sin(tw);
    sp[i+2] = ox*Math.sin(tw)+oz*Math.cos(tw);
  }
  geo.computeVertexNormals();
  const c = new THREE.Color(col);
  const mat = new THREE.MeshStandardMaterial({
    color:c, emissive:c, emissiveIntensity:0.8,
    roughness:0.2, metalness:0.8, transparent:true, opacity:0.9,
  });
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x, TERRAIN_Y+h/2, z);
  m.castShadow = true;
  scene.add(m);
  spires.push(m);
});

// â”€â”€ BIOLUMINESCENT FLORA â”€â”€
const floraOrbs = [];
for (let i = 0; i < 24; i++) {
  const x = (Math.random()-0.5)*55, z = -Math.random()*20-2;
  const h = 0.5 + Math.random()*2.5;
  const stalk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.04, 0.08, h, 4),
    new THREE.MeshStandardMaterial({ color:0x2a1040, roughness:0.9 })
  );
  stalk.position.set(x, TERRAIN_Y+h/2, z);
  scene.add(stalk);
  const orbR = 0.12 + Math.random()*0.25;
  const hue  = 0.65 + Math.random()*0.38;
  const col  = new THREE.Color().setHSL(hue, 1, 0.62);
  const orb  = new THREE.Mesh(
    new THREE.SphereGeometry(orbR, 6, 6),
    new THREE.MeshStandardMaterial({ color:col, emissive:col, emissiveIntensity:2.5 })
  );
  orb.position.set(x, TERRAIN_Y+h+orbR, z);
  orb.userData.ph = Math.random()*Math.PI*2;
  scene.add(orb);
  floraOrbs.push(orb);
}

// â”€â”€ FLOATING PARTICLES â”€â”€
const PCNT = 200;
const pGeo = new THREE.BufferGeometry();
const pBuf = new Float32Array(PCNT*3);
const pPh  = new Float32Array(PCNT);
for (let i = 0; i < PCNT; i++) {
  pBuf[i*3]   = (Math.random()-0.5)*50;
  pBuf[i*3+1] = TERRAIN_Y + 1 + Math.random()*12;
  pBuf[i*3+2] = -Math.random()*25;
  pPh[i] = Math.random()*Math.PI*2;
}
pGeo.setAttribute('position', new THREE.BufferAttribute(pBuf, 3));
const pMat = new THREE.PointsMaterial({
  color:0xcc88ff, size:0.07, transparent:true, opacity:0.6,
  blending:THREE.AdditiveBlending, depthWrite:false,
});
scene.add(new THREE.Points(pGeo, pMat));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DAY_CYCLE = 120;
let t0 = null;

function tick(ts) {
  if (!t0) t0 = ts;
  const ms  = ts - t0;
  const sec = ms / 1000;

  const dayPhase = (Math.sin(sec*Math.PI*2/DAY_CYCLE - Math.PI/2) + 1) / 2;
  const nightFactor = 1 - dayPhase;

  // Sun
  const sunA = sec*Math.PI*2/DAY_CYCLE - Math.PI/2;
  const SX = Math.cos(sunA)*170, SY = Math.sin(sunA)*110, SZ = -100;
  sunMesh.position.set(SX, SY, SZ);
  sunGlow.position.set(SX, SY, SZ);
  sunLight.position.set(SX, SY, SZ);
  const sunUp = Math.max(0, SY/110);
  sunLight.intensity = sunUp * 6;
  sunMesh.visible = SY > -20; sunGlow.visible = SY > -24;
  sunMesh.material.color.setHSL(0.12-sunUp*0.04, 1, 0.5+sunUp*0.14);
  sunLight.color.setHSL(0.10-sunUp*0.03, 0.9, 0.7+sunUp*0.1);
  skyUniforms.uDay.value  = dayPhase;
  skyUniforms.uSunY.value = SY/110;

  // Moon
  const mp = moonPos(sec, DAY_CYCLE);
  moonMesh.position.set(mp.x, mp.y, mp.z);
  moonGlow.position.set(mp.x, mp.y, mp.z);
  moonRim.position.set(mp.x, mp.y, mp.z);
  moonLight.position.set(mp.x, mp.y, mp.z);

  const moonAbove = mp.y > TERRAIN_Y + 2;
  moonMesh.visible = moonAbove;
  moonGlow.visible = moonAbove;
  moonRim.visible  = moonAbove;
  moonGlow.material.opacity = (0.3 + nightFactor * 0.7) * (moonAbove ? 1 : 0);
  moonLight.intensity = moonAbove ? (4.0 + nightFactor * 8.0) : 0;

  // Stars
  const nightF = Math.max(0, 1 - dayPhase * 2.2);
  const baseOps = [1.0, 0.85, 0.6];
  starData.forEach((layer, li) => {
    if (nightF <= 0) { layer.mat.opacity = 0; return; }
    layer.pts.rotation.y += 0.000005;
    const twinkle = 0.85 + 0.15 * Math.sin(sec * 0.6 + li * 2.1);
    layer.mat.opacity = nightF * baseOps[li] * twinkle;
  });

  // Ambient
  ambLight.color.setHSL(0.76, 0.7, 0.15 + dayPhase * 0.15);
  ambLight.intensity = 3.5 + nightFactor * 5.0;
  hemiLight.intensity = 1.5 + dayPhase * 2.0;
  terrMat.color.setHSL(0.78, 0.8, 0.08 + dayPhase * 0.1);
  terrMat.emissiveIntensity = 0.1 + nightFactor * 0.3;

  // Spires pulse
  spires.forEach((s,i) => {
    s.material.emissiveIntensity = 0.6 + Math.sin(sec*1.5+i*0.7)*0.3 + nightFactor * 2.0;
  });

  // Flora pulse
  floraOrbs.forEach(o => {
    o.material.emissiveIntensity = 2.2 + Math.sin(sec*2.0+o.userData.ph)*0.8 + nightFactor * 2.5;
  });

  // Particles
  const pp = pGeo.attributes.position.array;
  for (let i = 0; i < PCNT; i++) {
    pp[i*3+1] += 0.003 + Math.sin(pPh[i]+sec)*0.001;
    pp[i*3]   += Math.sin(pPh[i]*1.3+sec*0.3)*0.0015;
    if (pp[i*3+1] > TERRAIN_Y+14) pp[i*3+1] = TERRAIN_Y+1;
  }
  pGeo.attributes.position.needsUpdate = true;

  // Camera fixed
  camera.position.set(0, 2, 18);
  camera.lookAt(0, 15, -30);

  // Porthole
  updateHole(ms);

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}

requestAnimationFrame(tick);
</script>
</body>
</html>